Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    and
    break
    const
    continue
    fn
    for
    identifier
    in
    not
    or
    return
    stdin
    stdout
    var
    while

Grammar

Rule 0     S' -> statement
Rule 1     statement -> keyword arguments ;
Rule 2     arguments -> arguments , expression
Rule 3     arguments -> expression
Rule 4     expression -> expression plus term
Rule 5     expression -> expression times term
Rule 6     expression -> term
Rule 7     term -> number
Rule 8     term -> string

Terminals, with rules where they appear

,                    : 2
;                    : 1
and                  : 
break                : 
const                : 
continue             : 
error                : 
fn                   : 
for                  : 
identifier           : 
in                   : 
keyword              : 1
not                  : 
number               : 7
or                   : 
plus                 : 4
return               : 
stdin                : 
stdout               : 
string               : 8
times                : 5
var                  : 
while                : 

Nonterminals, with rules where they appear

arguments            : 1 2
expression           : 2 3 4 5
statement            : 0
term                 : 4 5 6

Parsing method: LALR

state 0

    (0) S' -> . statement
    (1) statement -> . keyword arguments ;

    keyword         shift and go to state 2

    statement                      shift and go to state 1

state 1

    (0) S' -> statement .



state 2

    (1) statement -> keyword . arguments ;
    (2) arguments -> . arguments , expression
    (3) arguments -> . expression
    (4) expression -> . expression plus term
    (5) expression -> . expression times term
    (6) expression -> . term
    (7) term -> . number
    (8) term -> . string

    number          shift and go to state 6
    string          shift and go to state 7

    arguments                      shift and go to state 3
    expression                     shift and go to state 4
    term                           shift and go to state 5

state 3

    (1) statement -> keyword arguments . ;
    (2) arguments -> arguments . , expression

    ;               shift and go to state 8
    ,               shift and go to state 9


state 4

    (3) arguments -> expression .
    (4) expression -> expression . plus term
    (5) expression -> expression . times term

    ;               reduce using rule 3 (arguments -> expression .)
    ,               reduce using rule 3 (arguments -> expression .)
    plus            shift and go to state 10
    times           shift and go to state 11


state 5

    (6) expression -> term .

    plus            reduce using rule 6 (expression -> term .)
    times           reduce using rule 6 (expression -> term .)
    ;               reduce using rule 6 (expression -> term .)
    ,               reduce using rule 6 (expression -> term .)


state 6

    (7) term -> number .

    plus            reduce using rule 7 (term -> number .)
    times           reduce using rule 7 (term -> number .)
    ;               reduce using rule 7 (term -> number .)
    ,               reduce using rule 7 (term -> number .)


state 7

    (8) term -> string .

    plus            reduce using rule 8 (term -> string .)
    times           reduce using rule 8 (term -> string .)
    ;               reduce using rule 8 (term -> string .)
    ,               reduce using rule 8 (term -> string .)


state 8

    (1) statement -> keyword arguments ; .

    $end            reduce using rule 1 (statement -> keyword arguments ; .)


state 9

    (2) arguments -> arguments , . expression
    (4) expression -> . expression plus term
    (5) expression -> . expression times term
    (6) expression -> . term
    (7) term -> . number
    (8) term -> . string

    number          shift and go to state 6
    string          shift and go to state 7

    expression                     shift and go to state 12
    term                           shift and go to state 5

state 10

    (4) expression -> expression plus . term
    (7) term -> . number
    (8) term -> . string

    number          shift and go to state 6
    string          shift and go to state 7

    term                           shift and go to state 13

state 11

    (5) expression -> expression times . term
    (7) term -> . number
    (8) term -> . string

    number          shift and go to state 6
    string          shift and go to state 7

    term                           shift and go to state 14

state 12

    (2) arguments -> arguments , expression .
    (4) expression -> expression . plus term
    (5) expression -> expression . times term

    ;               reduce using rule 2 (arguments -> arguments , expression .)
    ,               reduce using rule 2 (arguments -> arguments , expression .)
    plus            shift and go to state 10
    times           shift and go to state 11


state 13

    (4) expression -> expression plus term .

    plus            reduce using rule 4 (expression -> expression plus term .)
    times           reduce using rule 4 (expression -> expression plus term .)
    ;               reduce using rule 4 (expression -> expression plus term .)
    ,               reduce using rule 4 (expression -> expression plus term .)


state 14

    (5) expression -> expression times term .

    plus            reduce using rule 5 (expression -> expression times term .)
    times           reduce using rule 5 (expression -> expression times term .)
    ;               reduce using rule 5 (expression -> expression times term .)
    ,               reduce using rule 5 (expression -> expression times term .)

